## Synchronization and concurrency   
This document aims to provide comprehensive information about synchronization and concurrency.   
To outline the terminology used in this context:
- Synchronization: sharing a same resource between multiple threads safely
- concurrency: when multiple threads work simultaneously with execution lifetimes overlapping â€” instead of sequentially
- parallelism: same as concurrency but execution occurs at the same physical instant (impossible on one-core processor as opposed to concurrency)

>The word "sequential" is used as an antonym for both "concurrent" and "parallel"   

### synchronization   
synchronization provides safety(thread safety) for concurrent programs.      
it is actually addresses two concurrent program problems:
- Race condition(Thread interference)
- Memory visibility(Memory consistency Errors)

synchronization primitives:
- Locks (mutex,semaphore)
- Atomic operations (CAS,LL/SC)     

By applying these primitives we ensure that `critical section` won't be executed concurrently.   
>in the general case, critical sections will be blocking, even when implemented with non-blocking primitives.   

although critical section gets blocking even on non-blocking primitives but some literatures refer to is as fine-grained lock.
>With few exceptions, non-blocking algorithms use atomic read-modify-write primitives that the hardware must provide,      
> the most notable of which is `compare and swap (CAS)`.    
> However, the emerging field of `software transactional memory` promises standard abstractions for writing efficient non-blocking code.   

### Lock-Free Algorithms
Lock-Free means if one thread suspended, others can make progress.   
> "Non-blocking" was used as a synonym for "lock-free" in the literature until the introduction of obstruction-freedom in 2003.

In Java the package `java.util.concurrent.atomic` provides **lock-free thread-safe programming on single variables**.   
Atomic actions cannot be interleaved, so they can be used without fear of **thread interference**.
Until Java 8 classes in this package used **volatile variable** and a method with signature:
```
boolean compareAndSet(expectedValue, updateValue);
```
From Java 11 onwards, atomic classes used `VarHandle` instead of volatile variable  

>Atomic classes are designed primarily as building blocks for implementing non-blocking data structures and related infrastructure classes. 
>The compareAndSet method is not a general replacement for locking. 
>It applies only when critical updates for an object are confined to a single variable.   

### Context Switch   
Operating systems(kernel) use a `thread scheduler` to determine which threads should be currently executing.   
When a thread's allotted time is complete  but the thread has not finished processing, a context switch occurs.   
A **context switch** is the process of storing a thread's current state and later restoring the state of the thread to continue execution.    
>An interrupt is an event that alters the normal execution flow of a program and can be generated by hardware devices or even by the CPU itself.   
> When an interrupt occurs the current flow of execution is suspended and interrupt handler runs.    
> After the interrupt handler runs the previous execution flow is resumed.   

kernel uses **interrupts**, particularly timer interrupts, to interrupt threads at regular intervals or when specific conditions are met.    
This interruption triggers a context switch, allowing the kernel to save the state of the current thread and switch execution to a different thread.   
When a context switch is required, the operating system relies on interrupts, particularly **timer interrupts**, to interrupt the currently running thread or process and transfer control to the kernel.    
This interruption allows the kernel to perform the necessary steps for context switching, including saving the state of the current thread/process and selecting the next thread/process to run.   

### Memory Consistency Errors   
>Memory consistency errors occur when different threads have inconsistent views of what should be the same data.   

**happens-before relationship**(`Memory Visibility`):This relationship is simply a guarantee that memory writes by one specific statement are **visible** to another specific statement.       
The `synchronized and volatile constructs`, as well as the Thread.start() and Thread.join() methods, can form happens-before relationships. In particular:   
- **One Thread scenario**: Each action in a thread happens-before every action in that thread that comes later in the program's order.   
- **Synchronized block**: An unlock of a monitor happens-before every subsequent lock of that same monitor.   
- **Volatile field**: Writes and reads of volatile fields have similar memory consistency effects as entering and exiting monitors, but do not entail mutual exclusion locking.
- **Thread.start()**: A call to start on a thread happens-before any action in the started thread.
- **Thread#join()**: All actions in a thread happen-before any other thread successfully returns from a join on that thread.    

### Thread interference (Race Condition)   
>Interference happens when two operations, running in different threads, but acting on the same data, interleave.   
>This means that the two operations consist of multiple steps, and the sequences of steps overlap.   

Race condition: when The outcome is depends on interleaving of multiple threads.   
multiple threads access shared data concurrently, and the final outcome of the program depends on the specific order in which these threads are scheduled to execute.   
This can lead to unpredictable and undesirable behaviour.
its cases include:
- Check-Then-Ach
- Read-Modify-Write
### Liveness   
>A concurrent application's ability to execute in a timely manner is known as its liveness.     

liveness problems:   
- deadlock
- starvation
- livelock
### References
- [oracle memory consistency errors](https://docs.oracle.com/javase/tutorial/essential/concurrency/memconsist.html)    
- [oracle happens-before relationship docs](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility)   
- [oracle Thread interference](https://docs.oracle.com/javase/tutorial/essential/concurrency/interfere.html)
- [oracle Liveness](https://docs.oracle.com/javase/tutorial/essential/concurrency/liveness.html)
- [wikipedia concurrency](https://en.wikipedia.org/wiki/Concurrent_computing)
- [wikipedia non-blocking algorithms](https://en.wikipedia.org/wiki/Non-blocking_algorithm)
- [linux kernel interrupts lecture](https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html)   
