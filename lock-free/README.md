### Lock-Free Algorithms   
In Java the package `java.util.concurrent.atomic` provides **lock-free thread-safe programming on single variables**.   
Until Java 8 classes in this package used **volatile variable** and a method with signature:
```
boolean compareAndSet(expectedValue, updateValue);
```
From Java 11 onwards, atomic classes used `VarHandle` instead of volatile variable  

>Atomic classes are designed primarily as building blocks for implementing non-blocking data structures and related infrastructure classes. 
>The compareAndSet method is not a general replacement for locking. 
>It applies only when critical updates for an object are confined to a single variable.   

### Context Switch   
Operating systems(kernel) use a `thread scheduler` to determine which threads should be currently executing.   
When a thread's allotted time is complete  but the thread has not finished processing, a context switch occurs.   
A **context switch** is the process of storing a thread's current state and later restoring the state of the thread to continue execution.    
>An interrupt is an event that alters the normal execution flow of a program and can be generated by hardware devices or even by the CPU itself.   
> When an interrupt occurs the current flow of execution is suspended and interrupt handler runs.    
> After the interrupt handler runs the previous execution flow is resumed.   

kernel uses **interrupts**, particularly timer interrupts, to interrupt threads at regular intervals or when specific conditions are met.    
This interruption triggers a context switch, allowing the kernel to save the state of the current thread and switch execution to a different thread.   
When a context switch is required, the operating system relies on interrupts, particularly **timer interrupts**, to interrupt the currently running thread or process and transfer control to the kernel.    
This interruption allows the kernel to perform the necessary steps for context switching, including saving the state of the current thread/process and selecting the next thread/process to run.
### Memory Consistency Errors(oracle docs)
>Memory consistency errors occur when different threads have inconsistent views of what should be the same data.   

**happens-before relationship**(`Memory Visibility`):This relationship is simply a guarantee that memory writes by one specific statement are **visible** to another specific statement.       
The `synchronized and volatile constructs`, as well as the Thread.start() and Thread.join() methods, can form happens-before relationships. In particular:   
- **One Thread scenario**: Each action in a thread happens-before every action in that thread that comes later in the program's order.   
- **Synchronized block**: An unlock of a monitor happens-before every subsequent lock of that same monitor.   
- **Volatile field**: Writes and reads of volatile fields have similar memory consistency effects as entering and exiting monitors, but do not entail mutual exclusion locking.
- **Thread.start()**: A call to start on a thread happens-before any action in the started thread.
- **Thread#join()**: All actions in a thread happen-before any other thread successfully returns from a join on that thread.    

### Liveness(oracle docs)   
>A concurrent application's ability to execute in a timely manner is known as its liveness.     

liveness problems:   
- deadlock
- starvation
- livelock
### References
[linux kernel interrupts lecture](https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html)   
[oracle memory consistency errors](https://docs.oracle.com/javase/tutorial/essential/concurrency/memconsist.html)
[oracle happens-before relationship docs](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility)